name: LunchChat CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  DOCKER_IMAGE_NAME: lunchchat-backend
  DOCKER_REGISTRY: xoo1228

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 30

    outputs:
      image-tag: ${{ steps.set-tag.outputs.IMAGE_TAG }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build application
        run: ./gradlew build -x test --no-daemon --parallel

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ vars.DOCKERHUB_TOKEN }}

      - name: Set image tag
        id: set-tag
        run: |
          echo "IMAGE_TAG=main-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          platforms: linux/amd64
          tags: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:${{ steps.set-tag.outputs.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

  deploy-production:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 20

    strategy:
      fail-fast: false  # 한 서버 실패해도 다른 서버 계속 진행
      matrix:
        server: [
          { id: "server1", name: "Server-1" },
          { id: "server2", name: "Server-2" }
        ]

    steps:
      - name: Set server host
        id: set-host
        run: |
          if [ "${{ matrix.server.id }}" = "server1" ]; then
            echo "host=${{ secrets.SERVER1_HOST }}" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.server.id }}" = "server2" ]; then
            echo "host=${{ secrets.SERVER2_HOST }}" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to ${{ matrix.server.name }}
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ steps.set-host.outputs.host }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          timeout: 15m
          command_timeout: 10m
          script: |
            set -e  # 에러 발생 시 즉시 중단
            
            echo "🚀 ${{ matrix.server.name }} 배포 시작..."
            
            # 프로젝트 디렉토리 준비
            cd /home/ubuntu
            
            # 기존 애플리케이션 정지
            if [ -d "lunchchat-app" ]; then
              cd lunchchat-app
              docker-compose down || true
              cd ..
            fi
            
            # 최신 코드 클론 (shallow clone으로 속도 향상)
            rm -rf lunchchat-temp
            git clone --depth 1 ${{ github.server_url }}/${{ github.repository }}.git lunchchat-temp
            
            # 환경 변수 복사
            if [ -f "lunchchat-app/.env" ]; then
              cp lunchchat-app/.env lunchchat-temp/
            else
              echo "⚠️ .env 파일이 없습니다."
              exit 1
            fi
            
            # 기존 프로젝트 교체
            rm -rf lunchchat-app
            mv lunchchat-temp lunchchat-app
            cd lunchchat-app
            
            # FCM JSON 생성
            cat > firebase-service-account-key.json << 'FCMEOF'
            ${{ secrets.FCM_SERVICE_ACCOUNT_JSON }}
            FCMEOF
            chmod 600 firebase-service-account-key.json
            
            # GitHub Secrets 환경변수 추가
            cat >> .env << 'ENVEOF'
            
            # GitHub Secrets에서 추가된 환경변수들
            SECRET_KEY=${{ secrets.SECRET_KEY }}
            CLIENT_ID=${{ secrets.CLIENT_ID }}
            CLIENT_SECRET=${{ secrets.CLIENT_SECRET }}
            FCM_SERVICE_ACCOUNT_FILE=/app/firebase-service-account-key.json
            IMAGE_TAG=${{ needs.build-and-push.outputs.image-tag }}
            DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
            DOCKER_IMAGE_NAME=${{ env.DOCKER_IMAGE_NAME }}
            SPRING_PROFILES_ACTIVE=dev
            JPA_DDL_AUTO=create-drop
            ENVEOF
            
            # 로그 디렉토리 생성
            mkdir -p logs
            
            echo "📦 Docker 이미지 다운로드 중..."
            
            # Docker 이미지 미리 다운로드 (백그라운드에서 진행)
            docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:${{ needs.build-and-push.outputs.image-tag }} &
            PULL_PID=$!
            
            # 다운로드 진행 상황 모니터링
            for i in {1..60}; do
              if kill -0 $PULL_PID 2>/dev/null; then
                echo "이미지 다운로드 진행 중... ($i/60)"
                sleep 5
              else
                wait $PULL_PID
                PULL_EXIT_CODE=$?
                if [ $PULL_EXIT_CODE -eq 0 ]; then
                  echo "✅ 이미지 다운로드 완료!"
                  break
                else
                  echo "❌ 이미지 다운로드 실패 (exit code: $PULL_EXIT_CODE)"
                  exit 1
                fi
              fi
            done
            
            # 타임아웃 처리
            if kill -0 $PULL_PID 2>/dev/null; then
              kill $PULL_PID
              echo "❌ 이미지 다운로드 타임아웃 (5분)"
              exit 1
            fi
            
            echo "🚀 컨테이너 시작 중..."
            
            # 환경변수 내보내기
            export IMAGE_TAG=${{ needs.build-and-push.outputs.image-tag }}
            export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
            export DOCKER_IMAGE_NAME=${{ env.DOCKER_IMAGE_NAME }}
            
            # 컨테이너 시작 (pull 건너뛰기)
            docker-compose up -d backend --no-build
            
            echo "⏳ 애플리케이션 시작 대기 중..."
            sleep 30
            
            # 헬스 체크 (재시도 로직 개선)
            HEALTH_CHECK_SUCCESS=false
            for i in {1..15}; do
              if curl -f -m 10 http://localhost:8080/actuator/health >/dev/null 2>&1; then
                echo "✅ ${{ matrix.server.name }} 헬스 체크 성공!"
                HEALTH_CHECK_SUCCESS=true
                break
              fi
            
              if [ $i -eq 15 ]; then
                echo "❌ ${{ matrix.server.name }} 헬스 체크 최종 실패"
                echo "=== 컨테이너 상태 ==="
                docker ps
                echo "=== 애플리케이션 로그 ==="
                docker-compose logs --tail 50 backend
                exit 1
              fi
            
              echo "헬스 체크 재시도 ($i/15) - 10초 후 재시도..."
              sleep 10
            done
            
            if [ "$HEALTH_CHECK_SUCCESS" = true ]; then
              # 구 이미지 정리
              docker image prune -f
              echo "🎉 ${{ matrix.server.name }} 배포 완료!"
            fi

  verify-deployment:
    needs: deploy-production
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Verify Load Balancer
        run: |
          echo "🔍 로드밸런서 확인 중..."
          
          SUCCESS_COUNT=0
          TOTAL_CHECKS=10
          
          for i in $(seq 1 $TOTAL_CHECKS); do
            response=$(curl -s -o /dev/null -w "%{http_code}" -m 10 https://${{ secrets.LOAD_BALANCER_IP }}/actuator/health || echo "000")
            if [ "$response" = "200" ]; then
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              echo "✅ 로드밸런서 헬스 체크 성공 ($i/$TOTAL_CHECKS) - 성공률: $SUCCESS_COUNT/$i"
            else
              echo "⚠️ 로드밸런서 헬스 체크 실패: $response ($i/$TOTAL_CHECKS)"
            fi
            sleep 3
          done
          
          SUCCESS_RATE=$((SUCCESS_COUNT * 100 / TOTAL_CHECKS))
          echo "📊 최종 성공률: $SUCCESS_RATE% ($SUCCESS_COUNT/$TOTAL_CHECKS)"
          
          if [ $SUCCESS_RATE -ge 80 ]; then
            echo "🎉 배포 검증 성공! (성공률 80% 이상)"
          else
            echo "❌ 배포 검증 실패! (성공률 80% 미만)"
            exit 1
          fi
